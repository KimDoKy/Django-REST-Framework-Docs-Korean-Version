<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  
  <link rel="shortcut icon" href="../img/favicon.ico">
  <title>Testing - Django Rest Framework Docs Korean version</title>
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  <link rel="stylesheet" href="../css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../css/theme_extra.css" type="text/css" />
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css">
  
  <script>
    // Current page data
    var mkdocs_page_name = "Testing";
    var mkdocs_page_input_path = "Testing.md";
    var mkdocs_page_url = null;
  </script>
  
  <script src="../js/jquery-2.1.1.min.js" defer></script>
  <script src="../js/modernizr-2.8.3.min.js" defer></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script> 
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
      <div class="wy-side-nav-search">
        <a href=".." class="icon icon-home"> Django Rest Framework Docs Korean version</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
	<ul class="current">
	  
          
            <li class="toctree-l1">
		
    <a class="" href="..">Home</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../Requests/">Requests</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../Responses/">Responses</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../Views/">Views</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../Generic_views/">Generic views</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../ViewSets/">Viewsets</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../Routers/">Routers</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../Parsers/">Parsers</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../Renderers/">Renderers</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../Serializers/">Serializers</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../Serializer_fields/">Serializer fields</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../Serializer_relations/">Serializer relations</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../Validators/">Validators</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../Authentication/">Authentication</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../Permissions/">Permissions</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../Throttling/">Throttling</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../Filtering/">Filtering</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../Pagination/">Pagination</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../Versioning/">Versioning</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../Content_negotiation/">Content negotiation</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../Metadata/">Metadata</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../Schemas/">Schemas</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../Format_suffixes/">Format suffixes</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../Returning_URLs/">Returning URLs</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../Exceptions/">Exceptions</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../Status_Codes/">Status codes</a>
	    </li>
          
            <li class="toctree-l1 current">
		
    <a class="current" href="./">Testing</a>
    <ul class="subnav">
            
    <li class="toctree-l2"><a href="#django-rest-framework-testing">Django REST Framework - Testing</a></li>
    
        <ul>
        
            <li><a class="toctree-l3" href="#apirequestfactory">APIRequestFactory</a></li>
        
        </ul>
    

    </ul>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../Settings/">Settings</a>
	    </li>
          
        </ul>
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="..">Django Rest Framework Docs Korean version</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="..">Docs</a> &raquo;</li>
    
      
    
    <li>Testing</li>
    <li class="wy-breadcrumbs-aside">
      
    </li>
  </ul>
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <h1 id="django-rest-framework-testing">Django REST Framework - Testing</h1>
<p><em><strong>"Code without tests is broken as designed."<br />
"테스트가 없는 코드는 의도 한대로 작동하지 않는다." - Jacob Kaplan-Moss</strong></em></p>
<p>REST 프레임워크는 Django의 기존 테스트 프레임워크를 확장하고, API Requests 작성에 대한 지원을 향상시키는 서포트 클래스를 포함하고 있습니다.</p>
<h2 id="apirequestfactory">APIRequestFactory</h2>
<p>Django의 기존 <code>RequestFactory</code> 클래스를 확장합니다.</p>
<h3 id="creating-test-requests">Creating test requests</h3>
<p><code>APIRequestFactory</code> 클래스는 Django의 표준 <code>RequestFactory</code> 클래스와 거의 동일한 API를 지원합니다. 즉 표준 <code>.get()</code>, <code>.post()</code>, <code>.put()</code>, <code>.patch()</code>, <code>.delete()</code>, <code>.head()</code> 및 <code>.options()</code> 메서드를 모두 사용할 수 있습니다.</p>
<pre><code>rom rest_framework.test import APIRequestFactory

# 표준 `RequestFactory` API을 사용ㅎ여 POST request form을 만든다.
factory = APIRequestFactory()
request = factory.post('/notes/', {'title': 'new idea'})
</code></pre>

<h4 id="using-the-format-argument">Using the <code>format</code> argument</h4>
<p><code>post</code>,<code>put</code>,<code>patch</code>와 같은 requests를 만드는 메서드에는 content type을 사용하여 requests를 쉽게 생성 할 수 있도록 하는 argument가 포함되어 있습니다.</p>
<pre><code># Create a JSON POST request
factory = APIRequestFactory()
request = factory.post('/notes/', {'title': 'new idea'}, format='json')
</code></pre>

<p>기본적으로 사용 가능한 형식은 <code>multipart</code>와 <code>json</code>입니다. Django의 기존 <code>RequestFactory</code>와의 호환성을 위해 기본 형식은 <code>multipart</code>입니다.</p>
<p>더 많은 형식에 대한 정보는 <a href="http://www.django-rest-framework.org/api-guide/testing/#configuration">configuration section</a>을 참조하세요.</p>
<h4 id="explicitly-encoding-the-request-body">Explicitly encoding the request body</h4>
<p>request 본문을 명시적으로 인코딩해야 하는 경우 <code>context_type</code> 플래그를 설정하여 request 본문을 인코딩할 수 있습니다.</p>
<pre><code>request = factory.post('/notes/', json.dumps({'title': 'new idea'}), content_type='application/json')
</code></pre>

<h4 id="put-and-patch-with-form-data">PUT and PATCH with form data</h4>
<p>Django의 <code>RequestFactory</code>와 REST 프레임 워크의 <code>APIRequestFactory</code> 사이에 주목할 만한 차이점은 다중 파트 양식 데이터가 <code>.post()</code> 이외의 메소드로 인코딩된다는 것입니다.</p>
<p>예를 들어, <code>APIRequestFactory</code>를 사용하면 다음과 같이 <code>put</code>요청을 할 수 있습니다.</p>
<pre><code>factory = APIRequestFactory()
request = factory.put('/notes/547/', {'title': 'remember to email dave'})
</code></pre>

<p>Django의 <code>RequestFactory</code>를 사용하면 명시적으로 데이터를 직접 인코딩해야합니다.</p>
<pre><code>from django.test.client import encode_multipart, RequestFactory

factory = RequestFactory()
data = {'title': 'remember to email dave'}
content = encode_multipart('BoUnDaRyStRiNg', data)
content_type = 'multipart/form-data; boundary=BoUnDaRyStRiNg'
request = factory.put('/notes/547/', content, content_type=content_type)
</code></pre>

<h4 id="forcing-authentication">Forcing authentication</h4>
<p><code>RequestFactory</code>를 사용하여 직접 뷰를 테스트 할 때는 인증자격 증명을 작성하지않고 직접 자격요청을 인증하는 것이 편리합니다.</p>
<p>강제 요청을 인증하려면 <code>force_authenticate()</code> 메소드를 사용하십시오.</p>
<pre><code>from rest_framework.test import force_authenticate

factory = APIRequestFactory()
user = User.objects.get(username='olivia')
view = AccountDetail.as_view()

# Make an authenticated request to the view...
request = factory.get('/accounts/django-superstars/')
force_authenticate(request, user=user)
response = view(request)
</code></pre>

<p>이 메소드의 서명은 <code>force_authenticate(request, user = None, token = None)</code>입니다. 전화를 걸 때 사용자와 토큰 중 하나 또는 둘 모두가 설정 될 수 있습니다.</p>
<p>예를 들어, 토큰을 사용하여 강제로 인증하는 경우 다음과 같이 할 수 있습니다.</p>
<pre><code>user = User.objects.get(username='olivia')
request = factory.get('/accounts/django-superstars/')
force_authenticate(request, user=user, token=user.token)
</code></pre>

<hr />
<p><strong>Note</strong> : <code>APIRequestFactory</code>를 사용할 때 반환되는 객체는 Django의 표준 <code>HttpRequest</code>이며, REST 프레임워크의 Request 객체는 아니며 뷰가 호출 된 후에만 ​​생성됩니다.<br />
즉, request 객체에 직접 속성을 설정하면 항상 원하는 결과를 얻을 수 없을 수도 있습니다.<br />
예를 들어, <code>.token</code>을 직접 설정해도 아무 효과도 없으며 세선 인증을 사용하는 경우 <code>.user</code>를 직접 설정할 수 있습니다.</p>
<pre><code># Request은`SessionAuthentication`이 사용 중일 때에 만 인증합니다.
request = factory.get('/accounts/django-superstars/')
request.user = user
response = view(request)
</code></pre>

<hr />
<h4 id="forcing-csrf-validation">Forcing CSRF validation</h4>
<p>기본적으로 <code>APIRequestFactory</code>으로 생성 된 request에는 REST 프레임워크 뷰에 전달 될 때 CSRF 유효성 검사가 적용되지 않습니다.
CSRF 유효성 검사를 명시적으로 수행해야하는 경우, 팩토리를 인스턴스화 할 때 <code>enforce_csrf_checks</code> 플래그를 설정하면됩니다.</p>
<pre><code>factory = APIRequestFactory(enforce_csrf_checks=True)
</code></pre>

<hr />
<p><strong>Note</strong> : Django의 표준 <code>RequestFactory</code>는 이 옵션을 포함할 필요가 없다는 사실에 주목해야 합니다. Django를 사용할 때 뷰를 직접 테스트 할 때 실행되지 않는 미들웨어에서 CSRF 유효성 검사가 수행되기 때문입니다. REST 프레임워크를 사용할 때 뷰 내부에서 CSRF 유효성 검사가 수행되므로 요청 팩토리는 뷰 수준의 CSRF 검사를 비활성화해야합니다.</p>
<hr />
<h3 id="apiclient">APIClient</h3>
<p>Django의 기존 <code>Client</code>클래스를 확장합니다.</p>
<h4 id="making-requests">Making requests</h4>
<p><code>APIClient</code>클래스는 DJango의 표준 Client클래스와 동일한 요청 인터페이스를 지원합니다. 즉, <code>.get()</code>, <code>.post()</code>, <code>.put()</code>, <code>.patch()</code>, <code>.delete()</code>, <code>.head()</code>, <code>.options()</code> 메서드를 모두 사용할 수 있습니다.</p>
<pre><code>from rest_framework.test import APIClient

client = APIClient()
client.post('/notes/', {'title': 'new idea'}, format='json')
</code></pre>

<p>더 만은 정보는 <a href="http://www.django-rest-framework.org/api-guide/testing/#configuration">configuration section</a>를 참조하세요.</p>
<h4 id="authenticating">Authenticating</h4>
<h5 id="loginkwargs">.login(**kwargs)</h5>
<p><code>login</code>메소드는 Django의 <code>Cilent</code>클래스와 똑같이 작동합니다. 이렇게 하면 <code>SessionAuthentication</code>이 포함된 모든 views에 대한 요청을 인증 할 수 있습니다.</p>
<pre><code># Make all requests in the context of a logged in session.
client = APIClient()
client.login(username='lauren', password='secret')
</code></pre>

<p>로그아웃하려면 <code>logout</code>메소드를 호출하세요.</p>
<pre><code># Log out
client.logout()
</code></pre>

<p><code>login</code> 메소드는 <code>AJAX API</code>와의 상호 작용을 포함하는 웹 사이트와 같이 세션 인증을 사용하는 API를 테스트하는데 적합합니다.</p>
<h5 id="credentialskwargs">.credentials(**kwargs)</h5>
<p><code>credentials</code>메소드는 테스트 클라이언트가 모든 후속 요청에 포함 할 헤더를 설정하는데 사용할 수 있습니다.</p>
<pre><code>from rest_framework.authtoken.models import Token
from rest_framework.test import APIClient

# Include an appropriate `Authorization:` header on all requests.
token = Token.objects.get(user__username='lauren')
client = APIClient()
client.credentials(HTTP_AUTHORIZATION='Token ' + token.key)
</code></pre>

<p><code>credentials</code>를 다시 호출하면 기존 <code>credentials</code>을 덮어 씁니다. 인수없이 메서드를 호출하여 기존 <code>credentials</code>의 설정을 해제할 수 있습니다.</p>
<pre><code># Stop including any credentials
client.credentials()
</code></pre>

<p><code>credentials</code> 방법은 기본인증, OAuth1a과 OAuth2 인증 및 간단한 토큰 인증스키마와 같은 인증 헤더가 필요한 API를 테스트하는데 적합합니다.</p>
<h5 id="force_authenticateusernone-tokennone">.force_authenticate(user=None, token=None)</h5>
<p>때로는 인증을 생략하고 테스트 클라이언트의 모든 요청을 인증 된 것으로 자동처리하도록 할 수 있습니다.</p>
<p>이는 API를 테스트하고 있지만 테스트 요청을 하기 위해 유효한 자격 증명을 작성하지 않으려는 경우 유용한 단축키입니다.</p>
<pre><code>user = User.objects.get(username='lauren')
client = APIClient()
client.force_authenticate(user=user)
</code></pre>

<p>후속 요청을 인증 해제하려면 <code>force_authenticate</code>를 호출하여 사용자/토큰을 <code>None</code>으로 설정하세요.</p>
<pre><code>client.force_authenticate(user=None)
</code></pre>

<h4 id="csrf-validation">CSRF validation</h4>
<p>기본적으로 CSRF 유효성 검사는 APICLient를 사용할 떄 적합하지 않습니다. CSRF 유효성 검사를 명시적으로 활성화해야하는 경우 Client를 인스턴스화 할때 <code>enforce_csrf_checks</code>플래그를 설정하면 됩니다.</p>
<pre><code>client = APIClient(enforce_csrf_checks=True)
</code></pre>

<p>평소처럼 CSRF 유효성검사는 세션 인증 된 views에만 적용됩니다. 즉, 클라이언트가 <code>login()</code>을 호출하려 로그인한 경우에만 CSRF 유효성 검사가 수행됩니다.</p>
<hr />
<h3 id="requestsclient">RequestsClient</h3>
<p>RESR 프레임워크에는 <code>request</code>(Python 라이브러리)를 사용하여 애플리케이션과 상호 작용하는 client도 포함되어 있습니다. 다음과 같은 경우 유용하게 사용할 수 있습니다.</p>
<ul>
<li>주로 다른 Python 서비스의 API와의 인터페이스를 기대하고 있으며, client가 볼 수 있는 것과 동일한 수준에서 서비스를 테스트하려 할 때</li>
<li>준비 또는 실제 환경에 대해 실행할 수 있는 방식으로 테스트를 작성할 때 ("Live test" 참조)</li>
</ul>
<p>이는 requests 세션을 직접 사용하는 것과 동일한 인터페이스를 제공합니다.</p>
<pre><code>client = RequestsClient()
response = client.get('http://testserver/users/')
assert response.status_code == 200
</code></pre>

<p>requests client에서는 정규화 된 URL을 전달해야 합니다.</p>
<h4 id="requestsclient-and-working-with-the-database"><code>RequestsClient</code> and working with the database</h4>
<p><code>RequestsClient</code>클래스는 서비스 인터페이스만 상호 작용하는 테스트를 작성하려는 경우에 유용합니다. 이것은 Django 테스트 클라이언트를 사용하는 것보다 조금 더 엄격합니다. 모든 상호작용이 API를 통해 이루어져야하기 떄문입니다.
<code>RequestsClient</code>를 사용하는 경우 데이터베이스 모델과 직접 상호 작용하는 대신 테스트 설정 및 결과 주장(?)을 일반 API 호출로 수행해야합니다.
예를 들어, <code>Customer.objects.count () == 3</code>를 확인하는 대신 <code>customers</code> 마지막점을 나열하고 3개의 레코드가 있는지 확인하세요.</p>
<h4 id="headers-authentication">Headers &amp; Authentication</h4>
<p>custom 헤더와 인증자격 증명은 <code>requests.Session</code> 인스턴스를 사용할 때와 동일한 방식으로 제공 될 수 있습니다.</p>
<pre><code>from requests.auth import HTTPBasicAuth

client.auth = HTTPBasicAuth('user', 'pass')
client.headers.update({'x-test': 'true'})
</code></pre>

<h4 id="csrf">CSRF</h4>
<p><code>SessionAuthentication</code>을 사용하는 경우 <code>POST</code>, <code>PUT</code>, <code>PATCH</code>, <code>DELETE</code> 요청에 대해 CSRF 토큰을 포함해야합니다.
JavaScript 기반의 클라이언트가 사용하는 것과 동일한 흐름으로 수행 할 수 있습니다.<br />
먼저 CRSF 토큰을 얻기 위해 <code>GET</code> 요청을 하고 다음 요청에 토큰을 제시하십시오.</p>
<pre><code>client = RequestsClient()

# Obtain a CSRF token.
response = client.get('/homepage/')
assert response.status_code == 200
csrftoken = response.cookies['csrftoken']

# Interact with the API.
response = client.post('/organisations/', json={
    'name': 'MegaCorp',
    'status': 'active'
}, headers={'X-CSRFToken': csrftoken})
assert response.status_code == 200
</code></pre>

<h4 id="live-tests">Live tests</h4>
<p>신중하게 사용하면 <code>RequestsClient</code>와 <code>CoreAPIClient</code>가 모두 개발 환경에서 실행되거나 준비 서버 또는 프로덕션 환경에 직접 실행 될 수 있는 테스트 사례를 작성할 수 있습니다.
이럼 스타일로 몇 가지 핵심 기능 중 일부에 대한 기본 테스트를 만드는 것은 실제 서비스를 확인하는 강력한 방법입니다. 이렇게하려면 테스트가 고객 데이터에 직접 영향을 주지 않는 방식으로 실행되도록 설정 및 해제하는데 신중을 기해야합니다.</p>
<hr />
<h3 id="coreapiclient">CoreAPIClient</h3>
<p><code>CoreAPIClient</code>를 사용하면 <code>coreapi</code> (Python 클라이언트 라이브러리)를 사용하여 API와 상호 작용할 수 있습니다.</p>
<pre><code># Fetch the API schema
client = CoreAPIClient()
schema = client.get('http://testserver/schema/')

# Create a new organisation
params = {'name': 'MegaCorp', 'status': 'active'}
client.action(schema, ['organisations', 'create'], params)

# Ensure that the organisation exists in the listing
data = client.action(schema, ['organisations', 'list'])
assert(len(data) == 1)
assert(data == [{'name': 'MegaCorp', 'status': 'active'}])
</code></pre>

<h4 id="headers-authentication_1">Headers &amp; Authentication</h4>
<p>Customs 헤더와 인증은 <code>RequestsClient</code>와 비슷한 방식으로 <code>CoreAPIClient</code>와 함께 사용할 수 있습니다.</p>
<pre><code>from requests.auth import HTTPBasicAuth

client = CoreAPIClient()
client.session.auth = HTTPBasicAuth('user', 'pass')
client.session.headers.update({'x-test': 'true'})
</code></pre>

<hr />
<h3 id="test-cases">Test cases</h3>
<p>REST 프레임워크는 DJango 테스트 케이스 클래스를 반영하지만, Django의 기본 클라이언트 대신 <code>APIClient</code>를 사용하는 테스트 케이스 클래스를 포함합니다.</p>
<ul>
<li>APISimpleTestCase</li>
<li>APITransactionTestCase</li>
<li>APITestCase</li>
<li>APILiveServerTestCase</li>
</ul>
<h4 id="example">Example]</h4>
<p>Django 테스트케이스 클래스처럼 REST 프레임워크의 테스트 케이스 클래스 중 하나를 사용할 수 있습니다. <code>self.client</code> 속성은 <code>APIClient</code> 인스턴스입니다.</p>
<pre><code>from django.urls import reverse
from rest_framework import status
from rest_framework.test import APITestCase
from myproject.apps.core.models import Account

class AccountTests(APITestCase):
    def test_create_account(self):
        &quot;&quot;&quot;
        Ensure we can create a new account object.
        &quot;&quot;&quot;
        url = reverse('account-list')
        data = {'name': 'DabApps'}
        response = self.client.post(url, data, format='json')
        self.assertEqual(response.status_code, status.HTTP_201_CREATED)
        self.assertEqual(Account.objects.count(), 1)
        self.assertEqual(Account.objects.get().name, 'DabApps')
</code></pre>

<hr />
<h3 id="testing-responses">Testing responses</h3>
<h4 id="checking-the-response-data">Checking the response data</h4>
<p>테스트 응답의 유효성을 검사 할 때 완전히 렌더링 된 응답을 검사하는 것보다 응답이 생성 된 데이터를 검사하는 것이 더 편리합니다.</p>
<p>예를 들어, <code>response.data</code>를 검사하는 것이 더 쉽습니다.</p>
<pre><code>response = self.client.get('/users/4/')
self.assertEqual(response.data, {'id': 4, 'username': 'lauren'})
</code></pre>

<p><code>response.content</code>를 구문 분석한 결과를 검사하는 대신:</p>
<pre><code>response = self.client.get('/users/4/')
self.assertEqual(json.loads(response.content), {'id': 4, 'username': 'lauren'})
</code></pre>

<h4 id="rendering-responses">Rendering responses</h4>
<p><code>APIRequestFactory</code>를 사용하여 뷰를 직접 테스트하는 경우, 템플릿 응답의 렌더링이 Django의 내부 requests - response 에 의해 수행되기 때문에 반환되는 응답은 아직 렌더링되지 않습니다. <code>response.content</code>에 액세스하려면 먼저 응답을 렌더링해야합니다.</p>
<pre><code>view = UserDetail.as_view()
request = factory.get('/users/4')
response = view(request, pk='4')
response.render()  # Cannot access `response.content` without this.
self.assertEqual(response.content, '{&quot;username&quot;: &quot;lauren&quot;, &quot;id&quot;: 4}')
</code></pre>

<hr />
<h3 id="configuration">Configuration</h3>
<h4 id="setting-the-default-format">Setting the default format</h4>
<p>테스트 요청을하는 데 사용되는 기본 형식은 <code>TEST_REQUEST_DEFAULT_FORMAT</code> 설정 키를 사용하여 설정할 수 있습니다. 예를 들어, 테스트 요청을 항상 <code>JSON</code>을 사용하려면 <code>settings.py</code>파일에서 다음을 설정하세요.</p>
<pre><code>REST_FRAMEWORK = {
    ...
    'TEST_REQUEST_DEFAULT_FORMAT': 'json'
}
</code></pre>

<h4 id="setting-the-available-formats">Setting the available formats</h4>
<p>multipart 또는 <code>json</code> 요청 이외의 것을 사용하여 요청을 테스트해야하는 경우 <code>TEST_REQUEST_RENDERER_CLASSES</code> 설정을 설정하여 요청을 테스트 할 수 있습니다.</p>
<p>예를 들어, 테스트 요청에 <code>format = 'html'</code>을 추가하려면 <code>settings.py</code> 파일에 다음과 같은 내용이 추가합니다.</p>
<pre><code>REST_FRAMEWORK = {
    ...
    'TEST_REQUEST_RENDERER_CLASSES': (
        'rest_framework.renderers.MultiPartRenderer',
        'rest_framework.renderers.JSONRenderer',
        'rest_framework.renderers.TemplateHTMLRenderer'
    )
}
</code></pre>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../Settings/" class="btn btn-neutral float-right" title="Settings">Next <span class="icon icon-circle-arrow-right"></span></a>
      
      
        <a href="../Status_Codes/" class="btn btn-neutral" title="Status codes"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="http://www.mkdocs.org">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" style="cursor: pointer">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
      
        <span><a href="../Status_Codes/" style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
        <span style="margin-left: 15px"><a href="../Settings/" style="color: #fcfcfc">Next &raquo;</a></span>
      
    </span>
</div>
    <script>var base_url = '..';</script>
    <script src="../js/theme.js" defer></script>
      <script src="../search/main.js" defer></script>

</body>
</html>
